(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom'), require('react-dom/client'), require('react-dom/test-utils')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom', 'react-dom/client', 'react-dom/test-utils'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TestingLibraryReact = {}, global.React, global.ReactDOM, global.ReactDOMClient, global.ReactTestUtils));
})(this, (function (exports, React, ReactDOM, ReactDOMClient, testUtils) { 'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	function _interopNamespace(e) {
		if (e && e.__esModule) return e;
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n["default"] = e;
		return Object.freeze(n);
	}

	function _mergeNamespaces(n, m) {
		m.forEach(function (e) {
			e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
				if (k !== 'default' && !(k in n)) {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		});
		return Object.freeze(n);
	}

	var React__namespace = /*#__PURE__*/_interopNamespace(React);
	var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
	var ReactDOMClient__namespace = /*#__PURE__*/_interopNamespace(ReactDOMClient);
	var testUtils__namespace = /*#__PURE__*/_interopNamespace(testUtils);

	var build = {};

	var ansiStyles = {exports: {}};

	(function (module) {

	  const ANSI_BACKGROUND_OFFSET = 10;

	  const wrapAnsi256 = function (offset) {
	    if (offset === void 0) {
	      offset = 0;
	    }

	    return code => `\u001B[${38 + offset};5;${code}m`;
	  };

	  const wrapAnsi16m = function (offset) {
	    if (offset === void 0) {
	      offset = 0;
	    }

	    return (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
	  };

	  function assembleStyles() {
	    const codes = new Map();
	    const styles = {
	      modifier: {
	        reset: [0, 0],
	        // 21 isn't widely supported and 22 does the same thing
	        bold: [1, 22],
	        dim: [2, 22],
	        italic: [3, 23],
	        underline: [4, 24],
	        overline: [53, 55],
	        inverse: [7, 27],
	        hidden: [8, 28],
	        strikethrough: [9, 29]
	      },
	      color: {
	        black: [30, 39],
	        red: [31, 39],
	        green: [32, 39],
	        yellow: [33, 39],
	        blue: [34, 39],
	        magenta: [35, 39],
	        cyan: [36, 39],
	        white: [37, 39],
	        // Bright color
	        blackBright: [90, 39],
	        redBright: [91, 39],
	        greenBright: [92, 39],
	        yellowBright: [93, 39],
	        blueBright: [94, 39],
	        magentaBright: [95, 39],
	        cyanBright: [96, 39],
	        whiteBright: [97, 39]
	      },
	      bgColor: {
	        bgBlack: [40, 49],
	        bgRed: [41, 49],
	        bgGreen: [42, 49],
	        bgYellow: [43, 49],
	        bgBlue: [44, 49],
	        bgMagenta: [45, 49],
	        bgCyan: [46, 49],
	        bgWhite: [47, 49],
	        // Bright color
	        bgBlackBright: [100, 49],
	        bgRedBright: [101, 49],
	        bgGreenBright: [102, 49],
	        bgYellowBright: [103, 49],
	        bgBlueBright: [104, 49],
	        bgMagentaBright: [105, 49],
	        bgCyanBright: [106, 49],
	        bgWhiteBright: [107, 49]
	      }
	    }; // Alias bright black as gray (and grey)

	    styles.color.gray = styles.color.blackBright;
	    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	    styles.color.grey = styles.color.blackBright;
	    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	    for (const [groupName, group] of Object.entries(styles)) {
	      for (const [styleName, style] of Object.entries(group)) {
	        styles[styleName] = {
	          open: `\u001B[${style[0]}m`,
	          close: `\u001B[${style[1]}m`
	        };
	        group[styleName] = styles[styleName];
	        codes.set(style[0], style[1]);
	      }

	      Object.defineProperty(styles, groupName, {
	        value: group,
	        enumerable: false
	      });
	    }

	    Object.defineProperty(styles, 'codes', {
	      value: codes,
	      enumerable: false
	    });
	    styles.color.close = '\u001B[39m';
	    styles.bgColor.close = '\u001B[49m';
	    styles.color.ansi256 = wrapAnsi256();
	    styles.color.ansi16m = wrapAnsi16m();
	    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET); // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js

	    Object.defineProperties(styles, {
	      rgbToAnsi256: {
	        value: (red, green, blue) => {
	          // We use the extended greyscale palette here, with the exception of
	          // black and white. normal palette only has 4 greyscale shades.
	          if (red === green && green === blue) {
	            if (red < 8) {
	              return 16;
	            }

	            if (red > 248) {
	              return 231;
	            }

	            return Math.round((red - 8) / 247 * 24) + 232;
	          }

	          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
	        },
	        enumerable: false
	      },
	      hexToRgb: {
	        value: hex => {
	          const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));

	          if (!matches) {
	            return [0, 0, 0];
	          }

	          let {
	            colorString
	          } = matches.groups;

	          if (colorString.length === 3) {
	            colorString = colorString.split('').map(character => character + character).join('');
	          }

	          const integer = Number.parseInt(colorString, 16);
	          return [integer >> 16 & 0xFF, integer >> 8 & 0xFF, integer & 0xFF];
	        },
	        enumerable: false
	      },
	      hexToAnsi256: {
	        value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
	        enumerable: false
	      }
	    });
	    return styles;
	  } // Make the export immutable


	  Object.defineProperty(module, 'exports', {
	    enumerable: true,
	    get: assembleStyles
	  });
	})(ansiStyles);

	var collections = {};

	Object.defineProperty(collections, '__esModule', {
	  value: true
	});
	collections.printIteratorEntries = printIteratorEntries;
	collections.printIteratorValues = printIteratorValues;
	collections.printListItems = printListItems;
	collections.printObjectProperties = printObjectProperties;
	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	const getKeysOfEnumerableProperties = (object, compareKeys) => {
	  const keys = Object.keys(object).sort(compareKeys);

	  if (Object.getOwnPropertySymbols) {
	    Object.getOwnPropertySymbols(object).forEach(symbol => {
	      if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
	        keys.push(symbol);
	      }
	    });
	  }

	  return keys;
	};
	/**
	 * Return entries (for example, of a map)
	 * with spacing, indentation, and comma
	 * without surrounding punctuation (for example, braces)
	 */


	function printIteratorEntries(iterator, config, indentation, depth, refs, printer, // Too bad, so sad that separator for ECMAScript Map has been ' => '
	// What a distracting diff if you change a data structure to/from
	// ECMAScript Object or Immutable.Map/OrderedMap which use the default.
	separator) {
	  if (separator === void 0) {
	    separator = ': ';
	  }

	  let result = '';
	  let current = iterator.next();

	  if (!current.done) {
	    result += config.spacingOuter;
	    const indentationNext = indentation + config.indent;

	    while (!current.done) {
	      const name = printer(current.value[0], config, indentationNext, depth, refs);
	      const value = printer(current.value[1], config, indentationNext, depth, refs);
	      result += indentationNext + name + separator + value;
	      current = iterator.next();

	      if (!current.done) {
	        result += ',' + config.spacingInner;
	      } else if (!config.min) {
	        result += ',';
	      }
	    }

	    result += config.spacingOuter + indentation;
	  }

	  return result;
	}
	/**
	 * Return values (for example, of a set)
	 * with spacing, indentation, and comma
	 * without surrounding punctuation (braces or brackets)
	 */


	function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
	  let result = '';
	  let current = iterator.next();

	  if (!current.done) {
	    result += config.spacingOuter;
	    const indentationNext = indentation + config.indent;

	    while (!current.done) {
	      result += indentationNext + printer(current.value, config, indentationNext, depth, refs);
	      current = iterator.next();

	      if (!current.done) {
	        result += ',' + config.spacingInner;
	      } else if (!config.min) {
	        result += ',';
	      }
	    }

	    result += config.spacingOuter + indentation;
	  }

	  return result;
	}
	/**
	 * Return items (for example, of an array)
	 * with spacing, indentation, and comma
	 * without surrounding punctuation (for example, brackets)
	 **/


	function printListItems(list, config, indentation, depth, refs, printer) {
	  let result = '';

	  if (list.length) {
	    result += config.spacingOuter;
	    const indentationNext = indentation + config.indent;

	    for (let i = 0; i < list.length; i++) {
	      result += indentationNext;

	      if (i in list) {
	        result += printer(list[i], config, indentationNext, depth, refs);
	      }

	      if (i < list.length - 1) {
	        result += ',' + config.spacingInner;
	      } else if (!config.min) {
	        result += ',';
	      }
	    }

	    result += config.spacingOuter + indentation;
	  }

	  return result;
	}
	/**
	 * Return properties of an object
	 * with spacing, indentation, and comma
	 * without surrounding punctuation (for example, braces)
	 */


	function printObjectProperties(val, config, indentation, depth, refs, printer) {
	  let result = '';
	  const keys = getKeysOfEnumerableProperties(val, config.compareKeys);

	  if (keys.length) {
	    result += config.spacingOuter;
	    const indentationNext = indentation + config.indent;

	    for (let i = 0; i < keys.length; i++) {
	      const key = keys[i];
	      const name = printer(key, config, indentationNext, depth, refs);
	      const value = printer(val[key], config, indentationNext, depth, refs);
	      result += indentationNext + name + ': ' + value;

	      if (i < keys.length - 1) {
	        result += ',' + config.spacingInner;
	      } else if (!config.min) {
	        result += ',';
	      }
	    }

	    result += config.spacingOuter + indentation;
	  }

	  return result;
	}

	var AsymmetricMatcher = {};

	Object.defineProperty(AsymmetricMatcher, '__esModule', {
	  value: true
	});
	AsymmetricMatcher.test = AsymmetricMatcher.serialize = AsymmetricMatcher.default = void 0;
	var _collections$3 = collections;

	var global$2 = function () {
	  if (typeof globalThis !== 'undefined') {
	    return globalThis;
	  } else if (typeof global$2 !== 'undefined') {
	    return global$2;
	  } else if (typeof self !== 'undefined') {
	    return self;
	  } else if (typeof window !== 'undefined') {
	    return window;
	  } else {
	    return Function('return this')();
	  }
	}();

	var Symbol$2 = global$2['jest-symbol-do-not-touch'] || global$2.Symbol;
	const asymmetricMatcher = typeof Symbol$2 === 'function' && Symbol$2.for ? Symbol$2.for('jest.asymmetricMatcher') : 0x1357a5;
	const SPACE$2 = ' ';

	const serialize$6 = (val, config, indentation, depth, refs, printer) => {
	  const stringedValue = val.toString();

	  if (stringedValue === 'ArrayContaining' || stringedValue === 'ArrayNotContaining') {
	    if (++depth > config.maxDepth) {
	      return '[' + stringedValue + ']';
	    }

	    return stringedValue + SPACE$2 + '[' + (0, _collections$3.printListItems)(val.sample, config, indentation, depth, refs, printer) + ']';
	  }

	  if (stringedValue === 'ObjectContaining' || stringedValue === 'ObjectNotContaining') {
	    if (++depth > config.maxDepth) {
	      return '[' + stringedValue + ']';
	    }

	    return stringedValue + SPACE$2 + '{' + (0, _collections$3.printObjectProperties)(val.sample, config, indentation, depth, refs, printer) + '}';
	  }

	  if (stringedValue === 'StringMatching' || stringedValue === 'StringNotMatching') {
	    return stringedValue + SPACE$2 + printer(val.sample, config, indentation, depth, refs);
	  }

	  if (stringedValue === 'StringContaining' || stringedValue === 'StringNotContaining') {
	    return stringedValue + SPACE$2 + printer(val.sample, config, indentation, depth, refs);
	  }

	  return val.toAsymmetricMatcher();
	};

	AsymmetricMatcher.serialize = serialize$6;

	const test$6 = val => val && val.$$typeof === asymmetricMatcher;

	AsymmetricMatcher.test = test$6;
	const plugin$6 = {
	  serialize: serialize$6,
	  test: test$6
	};
	var _default$2k = plugin$6;
	AsymmetricMatcher.default = _default$2k;

	var ConvertAnsi = {};

	var ansiRegex = function (_temp) {
	  let {
	    onlyFirst = false
	  } = _temp === void 0 ? {} : _temp;
	  const pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
	  return new RegExp(pattern, onlyFirst ? undefined : 'g');
	};

	Object.defineProperty(ConvertAnsi, '__esModule', {
	  value: true
	});
	ConvertAnsi.test = ConvertAnsi.serialize = ConvertAnsi.default = void 0;

	var _ansiRegex = _interopRequireDefault$9(ansiRegex);

	var _ansiStyles$1 = _interopRequireDefault$9(ansiStyles.exports);

	function _interopRequireDefault$9(obj) {
	  return obj && obj.__esModule ? obj : {
	    default: obj
	  };
	}
	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */


	const toHumanReadableAnsi = text => text.replace((0, _ansiRegex.default)(), match => {
	  switch (match) {
	    case _ansiStyles$1.default.red.close:
	    case _ansiStyles$1.default.green.close:
	    case _ansiStyles$1.default.cyan.close:
	    case _ansiStyles$1.default.gray.close:
	    case _ansiStyles$1.default.white.close:
	    case _ansiStyles$1.default.yellow.close:
	    case _ansiStyles$1.default.bgRed.close:
	    case _ansiStyles$1.default.bgGreen.close:
	    case _ansiStyles$1.default.bgYellow.close:
	    case _ansiStyles$1.default.inverse.close:
	    case _ansiStyles$1.default.dim.close:
	    case _ansiStyles$1.default.bold.close:
	    case _ansiStyles$1.default.reset.open:
	    case _ansiStyles$1.default.reset.close:
	      return '</>';

	    case _ansiStyles$1.default.red.open:
	      return '<red>';

	    case _ansiStyles$1.default.green.open:
	      return '<green>';

	    case _ansiStyles$1.default.cyan.open:
	      return '<cyan>';

	    case _ansiStyles$1.default.gray.open:
	      return '<gray>';

	    case _ansiStyles$1.default.white.open:
	      return '<white>';

	    case _ansiStyles$1.default.yellow.open:
	      return '<yellow>';

	    case _ansiStyles$1.default.bgRed.open:
	      return '<bgRed>';

	    case _ansiStyles$1.default.bgGreen.open:
	      return '<bgGreen>';

	    case _ansiStyles$1.default.bgYellow.open:
	      return '<bgYellow>';

	    case _ansiStyles$1.default.inverse.open:
	      return '<inverse>';

	    case _ansiStyles$1.default.dim.open:
	      return '<dim>';

	    case _ansiStyles$1.default.bold.open:
	      return '<bold>';

	    default:
	      return '';
	  }
	});

	const test$5 = val => typeof val === 'string' && !!val.match((0, _ansiRegex.default)());

	ConvertAnsi.test = test$5;

	const serialize$5 = (val, config, indentation, depth, refs, printer) => printer(toHumanReadableAnsi(val), config, indentation, depth, refs);

	ConvertAnsi.serialize = serialize$5;
	const plugin$5 = {
	  serialize: serialize$5,
	  test: test$5
	};
	var _default$2j = plugin$5;
	ConvertAnsi.default = _default$2j;

	var DOMCollection$1 = {};

	Object.defineProperty(DOMCollection$1, '__esModule', {
	  value: true
	});
	DOMCollection$1.test = DOMCollection$1.serialize = DOMCollection$1.default = void 0;
	var _collections$2 = collections;
	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	/* eslint-disable local/ban-types-eventually */

	const SPACE$1 = ' ';
	const OBJECT_NAMES = ['DOMStringMap', 'NamedNodeMap'];
	const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;

	const testName = name => OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);

	const test$4 = val => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);

	DOMCollection$1.test = test$4;

	const isNamedNodeMap = collection => collection.constructor.name === 'NamedNodeMap';

	const serialize$4 = (collection, config, indentation, depth, refs, printer) => {
	  const name = collection.constructor.name;

	  if (++depth > config.maxDepth) {
	    return '[' + name + ']';
	  }

	  return (config.min ? '' : name + SPACE$1) + (OBJECT_NAMES.indexOf(name) !== -1 ? '{' + (0, _collections$2.printObjectProperties)(isNamedNodeMap(collection) ? Array.from(collection).reduce((props, attribute) => {
	    props[attribute.name] = attribute.value;
	    return props;
	  }, {}) : { ...collection
	  }, config, indentation, depth, refs, printer) + '}' : '[' + (0, _collections$2.printListItems)(Array.from(collection), config, indentation, depth, refs, printer) + ']');
	};

	DOMCollection$1.serialize = serialize$4;
	const plugin$4 = {
	  serialize: serialize$4,
	  test: test$4
	};
	var _default$2i = plugin$4;
	DOMCollection$1.default = _default$2i;

	var DOMElement = {};

	var markup = {};

	var escapeHTML$2 = {};

	Object.defineProperty(escapeHTML$2, '__esModule', {
	  value: true
	});

	escapeHTML$2.default = escapeHTML$1;
	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */


	function escapeHTML$1(str) {
	  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
	}

	Object.defineProperty(markup, '__esModule', {
	  value: true
	});
	markup.printText = markup.printProps = markup.printElementAsLeaf = markup.printElement = markup.printComment = markup.printChildren = void 0;

	var _escapeHTML = _interopRequireDefault$8(escapeHTML$2);

	function _interopRequireDefault$8(obj) {
	  return obj && obj.__esModule ? obj : {
	    default: obj
	  };
	}
	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	// Return empty string if keys is empty.


	const printProps$1 = (keys, props, config, indentation, depth, refs, printer) => {
	  const indentationNext = indentation + config.indent;
	  const colors = config.colors;
	  return keys.map(key => {
	    const value = props[key];
	    let printed = printer(value, config, indentationNext, depth, refs);

	    if (typeof value !== 'string') {
	      if (printed.indexOf('\n') !== -1) {
	        printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
	      }

	      printed = '{' + printed + '}';
	    }

	    return config.spacingInner + indentation + colors.prop.open + key + colors.prop.close + '=' + colors.value.open + printed + colors.value.close;
	  }).join('');
	}; // Return empty string if children is empty.


	markup.printPro